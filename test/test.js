/* eslint-env mocha */

import fs from 'fs'
import { encodeL, encode, decodeL, decode } from '../src/index.js'

describe('base1', () => {
  describe('encodeL and decodeL', () => {
    describe('encodeL', () => {
      it('works', () => {
        expect(encodeL(Uint8Array.from([]))).toBe(0n)
        expect(encodeL(Uint8Array.from([0]))).toBe(1n)
        expect(encodeL(Uint8Array.from([17]))).toBe(18n)
        expect(encodeL(Uint8Array.from([255]))).toBe(256n)
        expect(encodeL(Uint8Array.from([0, 0]))).toBe(257n)
        expect(encodeL(Uint8Array.from([255, 255]))).toBe(65792n)
        expect(encodeL(Uint8Array.from([0, 0, 0]))).toBe(65793n)
        expect(encodeL(Uint8Array.from([255, 255, 255]))).toBe(16843008n)
        expect(encodeL(Uint8Array.from([0, 0, 0, 0]))).toBe(16843009n)
      })

      it('edge cases', () => {
        expect(encodeL(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]))).toBe(BigInt(Number.MAX_SAFE_INTEGER))
        expect(encodeL(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]))).toBe(9007199254740991n)
        expect(encodeL(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF]))).toBe(9007199254740992n)
        expect(encodeL(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0x00]))).toBe(9007199254740993n)

        // One below Number.MAX_VALUE
        expect(encodeL(Uint8Array.from([0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF6, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]))).toBe(BigInt(Number.MAX_VALUE) - 1n)

        // Exactly Number.MAX_VALUE
        expect(encodeL(Uint8Array.from([0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF6, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF]))).toBe(BigInt(Number.MAX_VALUE))

        // One above Number.MAX_VALUE
        expect(encodeL(Uint8Array.from([0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF6, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0x00]))).toBe(BigInt(Number.MAX_VALUE) + 1n)
      })
    })

    describe('decodeL', () => {
      it('wants a non-negative BigInt', () => {
        expect(() => decodeL(8)).toThrowError('This is not a non-negative BigInt')
        expect(() => decodeL(-1n)).toThrowError('This is not a non-negative BigInt')
      })

      it('works', () => {
        expect(decodeL(0n)).toEqual(Uint8Array.from([]))
        expect(decodeL(1n)).toEqual(Uint8Array.from([0]))
        expect(decodeL(18n)).toEqual(Uint8Array.from([17]))
        expect(decodeL(256n)).toEqual(Uint8Array.from([255]))
        expect(decodeL(257n)).toEqual(Uint8Array.from([0, 0]))
        expect(decodeL(65792n)).toEqual(Uint8Array.from([255, 255]))
        expect(decodeL(65793n)).toEqual(Uint8Array.from([0, 0, 0]))
        expect(decodeL(16843008n)).toEqual(Uint8Array.from([255, 255, 255]))
        expect(decodeL(16843009n)).toEqual(Uint8Array.from([0, 0, 0, 0]))
      })

      it('edge cases', () => {
        expect(decodeL(BigInt(Number.MAX_SAFE_INTEGER))).toEqual(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]))
        expect(decodeL(9007199254740991n)).toEqual(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE]))
        expect(decodeL(9007199254740992n)).toEqual(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF]))
        expect(decodeL(9007199254740993n)).toEqual(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0x00]))

        expect(decodeL(BigInt(Number.MAX_VALUE))).toEqual(Uint8Array.from([0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF6, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF]))
      })
    })

    describe('round trips', () => {
      it('work', () => {
        expect(decodeL(encodeL(new Uint8Array(10).fill(1)))).toEqual(new Uint8Array(10).fill(1))
        expect(decodeL(encodeL(new Uint8Array(100).fill(1)))).toEqual(new Uint8Array(100).fill(1))
        expect(decodeL(encodeL(new Uint8Array(1000).fill(1)))).toEqual(new Uint8Array(1000).fill(1))
        expect(decodeL(encodeL(new Uint8Array(10000).fill(1)))).toEqual(new Uint8Array(10000).fill(1))
      })
    })
  })

  describe('encode and decode', () => {
    describe('encode', () => {
      it('throws on a bad BigInt length', () => {
        expect(() => encode(Uint8Array.from([0x1E, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF, 0x00]))).toThrowError('Could not compute the Base1 output length as a number')
      })

      it('throws on too large an input', () => {
        expect(() => encode(Uint8Array.from([0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF6, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF]))).toThrowError('Invalid string length')
      })
    })

    describe('round trips', () => {
      const pairsDir = './test/pairs'
      fs.readdirSync(pairsDir)
        .filter(fileName => fileName.endsWith('.base1'))
        .forEach(fileName => {
          const caseName = fileName.substring(0, fileName.length - '.base1'.length)
          it(caseName, () => {
            const base1 = fs.readFileSync(pairsDir + '/' + caseName + '.base1', 'utf8')
            const binary = Uint8Array.from(fs.readFileSync(pairsDir + '/' + caseName + '.bin'))
            expect(decode(base1)).toEqual(binary)
            expect(encode(binary)).toBe(base1)
          })
        })
    })

    describe('invalid Base1', () => {
      const badDir = './test/bad'
      fs.readdirSync(badDir)
        .filter(fileName => fileName.endsWith('.base1'))
        .forEach(fileName => {
          const caseName = fileName.substring(0, fileName.length - '.base1'.length)
          it(caseName, () => {
            const base1 = fs.readFileSync(badDir + '/' + caseName + '.base1', 'utf8')
            expect(() => decode(base1)).toThrowError('This is not a valid Base1 string')
          })
        })
    })
  })
})
